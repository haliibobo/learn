package com.github.haliibobo.learn.guava.limiter;

import com.google.common.util.concurrent.RateLimiter;
import org.junit.Test;

/**
 * say something.
 *
 * @author lizibo
 * @version 1.0
 * @date 2020-06-02 16:35
 * 令牌桶算法：
 * 1，令牌按固定速率发放，生成的令牌放入令牌桶中。2，令牌桶有容量限制，当桶满时，新生成的令牌会被丢弃。
 * 3，请求到来时，先从令牌桶中获取令牌，如果取得，则执行请求；如果令牌桶为空，则丢弃该请求。
 * 令牌桶算法可以把请求平均分散在时间段内，是使用较为广发的限流算法。
 *
 * 令牌桶算法基本思路是按照恒定的速率向桶中放入令牌，每当请求经过时则消耗一个或多个令牌。当桶中的令牌为 0 时，请求则会被阻塞
 *
 * 具体算法：
 *
 * ·假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌；
 *
 * ·桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；
 *
 * ·当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上；
 *
 * ·如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。
 *
 * 备注：令牌桶算法支持先消费后付款，比如一个请求可以获取多个甚至全部的令牌，但是需要后面的请求付费。也就是说后面的请求需要等到桶中的令牌补齐之后才能继续获取。
 *
 *
 * 漏桶（leaky bucket）
 *
 * ·一个固定容量的漏桶，按照常量固定速率流出水滴；
 *
 * ·如果桶是空的，则不需流出水滴；
 *
 * ·可以以任意速率流入水滴到漏桶；
 *
 * ·如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。
 *
 *
 * 算法和令牌桶（token bucket）算法
 */
public class RateLimitLearn {



    /**
     * 当令牌不足时，acquire方法并不会阻塞本次调用，而是会算在下次调用的头上。
     * 比如第一次调用时，令牌桶中并没有令牌，但是第一次调用也没有阻塞，而是在第二次调用的时候阻塞了1秒。
     * 也就是说，每次调用欠的令牌（如果桶中令牌不足）都是让下一次调用买单
     * 如果每次请求都为本次买单会有不必要的等待。
     * 比如说令牌增加的速度为每秒1个，初始时桶中没有令牌，这时来了个请求需要100个令牌，那需要等待100s后才能开始这个任务。
     * 所以更好的办法是先放行这个请求，然后延迟之后的请求
     */
    @Test
    public void test(){
        //create方法传入的是每秒生成令牌的个数
        RateLimiter rateLimiter= RateLimiter.create(1);
        for (int i = 0; i < 5; i++) {
            //acquire方法传入的是需要的令牌个数，当令牌不足时会进行等待，该方法返回的是等待的时间
            double waitTime=rateLimiter.acquire(10);
            System.out.println(System.currentTimeMillis()/1000+" , "+waitTime);
        }
    }

}
